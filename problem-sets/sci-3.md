# SCI-3

## Pre

我们推荐你在做本部分题目时，可以学习一下使用 Python 做图（实在不行 Excel 也可以）进行分析的基本使用方法。能看懂基本 LaTeX 公式。学会使用上一个题目提到的 `Environment Modules` 做基本的软件版本、依赖库版本管理（不然你会被各种依赖库的冲突搞哭的）。

一些相关资料：

1. [LaTeX 简明教程](https://liam.page/2014/09/08/latex-introduction/)
2. [LaTeX 表格生成器](https://www.latex-tables.com/)
3. [Vscode 搭建 LaTeX 写作环境](https://zhuanlan.zhihu.com/p/139210056)
4. [overleaf - 在线 LaTeX 写作平台](https://www.overleaf.com/)

## Problems

> 要求：学会 OpenMP、MPI、CUDA 程序编译，学会 BLAS 库的编译使用。学习一些基本的使用 OpenMP、MPI 等进行上层算法优化的知识。

### upper_level_algorithm_opt

你可能打过算法竞赛，我们也非常推荐你通过打比赛去提升下自己的专业水平。但你有没有想过，现实中的算法优化难道仅限于你算法竞赛中接触的各种奇淫技巧吗？当然不是，既然你进入了 HPC 领域，就必须了解下多核计算机、异构架构中我们更常使用的优化方法。随着摩尔定律的终结，多核计算机的出现和发展是必然趋势，同时如 CUDA 等异构架构的异军突起也象征着计算机体系结构的新时代的到来。

我们在 [codes/upper_level_algorithm_opt](../codes/upper_level_algorithm_opt/README.md) 目录下存放了本题目需要的源代码。

源代码解决的问题都相同：即给定 A、B 矩阵的矩阵乘法，数据集使用其中的 `datagen` 进行生成。建议先查看 [codes/upper_level_algorithm_opt/README.md](../codes/upper_level_algorithm_opt/README.md) 文档了解解决问题解释和使用方法。

我们要求你首先会手动编译（不借助 Makefile、CMake 等自动构建工具） `src` 目录下的8个源代码，一个数据集生成程序和7个不同方法的矩阵乘法程序。

每个矩阵乘法程序都会使用 C++ chrono 系统级高分辨率计数器进行程序运行时间的统计，该时间作为我们衡量应用性能的一个指标。我们希望你能获取这些数据，并将其做成图表进行分析，可以做成表格形式，如：

|程序/数据|1000-1000-1000.0|1000-1000-1000.1|
|-|-|-|
|general|3.4s|4.4s|
|openmp|0.03s|0.023s|

上述表格仅作为格式参考，你可以做成任何形式、任何数量的表格，能够清晰表示出各个程序之间针对不同矩阵规模的运行时间的比较即可。

在实际性能测试、分析中，我们一般不使用单一指标（最大、最小、算数/几何平均、中位数），且要测量多次。你可以用更专业的表示形式，如折线图、箱型图等结合必要的表格进行性能比较。

有关性能分析工程，感兴趣的可以参考 Dror G. Feitelson 所著的 [Workload Modeling for Computer Systems Performance Evaluation](https://www.cs.huji.ac.il/w~feit/wlmod/) 了解更多关于模态分布、偏度等主题的阐述。

手动编译完成后，你可以制作一个 Makefile 或 CMake 脚本来进行自动化构建。NVIDIA HPC SDK 在 CMake 上的支持可能不够好，这里推荐一个新型国产自动化构建软件 [xmake](https://xmake.io/#/)。

---

**报告要求：**
**1. 无论有无做修改，提交你做题时使用的 upper_level_algorithm 目录下的代码、日志，测试的矩阵大小指明在 matrix_size.txt 文件中，无需提交编译生成的二进制文件。根据报告情况，我们可能需要进行复现。当然，你可以把改动后的代码上传到你的 Github/Gitee 上等，报告时提供链接。**
**2. 手动编译程序、成功运行程序的截图，程序运行输出的日志文件，可以使用 `<program> 2>&1 | tee xxx.log` 生成日志，我们推荐写一个自动化脚来生成日志，存放在 logs 目录。写一个 Python 脚本配合必要的 `sed` `awk` 等 Linux 数据处理命令来生成图表是值得赞赏的。**
**3. 分析一下源程序，包括程序执行的流程，进行矩阵乘法的原理。比较串行程序和 MPI、OPENMP、CUDA、OpenBlas 程序的不同，为什么产生了加速的效果。你可以直接源代码中加上自己的注释。**
**4. OPENMP 程序中，我们写死了启动的线程数 num_threads，请你换用不同线程数编译或者修改程序使其读取环境变量 `OMP_NUM_THREADS` 来启动对应的线程数，比较不同线程数下矩阵乘法的执行时间等情况。**
**5. MPI 程序可以指定启动的进程数，请你使用不同的进程数来比较不同进程数量下矩阵乘法的执行时间等情况。**
**6. MPI + OPENMP 程序相对 OPENMP 程序可扩展性更高，相对 MPI 程序其启动开销更小，请你使用不同的进程/线程数量来比较一下每组的性能。**
**7.（可选）实际上，MPI、OPENMP 程序启动时最好设置一下亲和度绑定，请你解释一下亲和度绑定，分析一下做题是你使用机器的结构如 NUMA 结构等，使用 `hwloc` 库的 `lstopo` 命令可以清晰地看到。可以的话比较一下不同亲和度绑定策略下 MPI、OPENMP 程序的性能。**
**8.（可选）CUDA 程序第一次运行和后面几次运行可能在性能上会有很大的不同，请你分析下可能的原因。**
**9.（可选）换用不同 MPI 实现、Blas 库比较一下性能区别。**
**10.（可选）请你针对 OPENMP、MPI、MPI + OPENMP 程序分析一下缓存一致性，看看能不能使其适应你机器上的 L1、L2 cache 来达到优化效果。**
**11.（可选）除了我们使用的优化方法，其实还有 SIMD 优化，请你了解一下 SIMD 相关知识，并在条件允许的情况下写一个 SIMD 优化的矩阵乘法程序。**
**12.（可选）了解一下屋顶线模型 Roofline Model，写出你的理解，看看能不能应用到上述的题目中。**

---

## After

推荐阅读书籍：

1. 《大规模并行处理器程序设计》
2. 《通用图形处理器设计 GPGPU 编程模型与架构原理》